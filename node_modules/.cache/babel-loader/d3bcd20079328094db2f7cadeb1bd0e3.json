{"ast":null,"code":"import * as ip from './ip.js';\nimport { getProtocol } from './protocols-table.js';\nimport { CID } from 'multiformats/cid';\nimport { base32 } from 'multiformats/bases/base32';\nimport { base58btc } from 'multiformats/bases/base58';\nimport * as Digest from 'multiformats/hashes/digest';\nimport varint from 'varint';\nimport { toString as uint8ArrayToString } from 'uint8arrays/to-string';\nimport { fromString as uint8ArrayFromString } from 'uint8arrays/from-string';\nimport { concat as uint8ArrayConcat } from 'uint8arrays/concat';\n/**\n * converts (serializes) addresses\n */\n\nexport function convert(proto, a) {\n  if (a instanceof Uint8Array) {\n    return convertToString(proto, a);\n  } else {\n    return convertToBytes(proto, a);\n  }\n}\n/**\n * Convert [code,Uint8Array] to string\n */\n\nexport function convertToString(proto, buf) {\n  const protocol = getProtocol(proto);\n\n  switch (protocol.code) {\n    case 4: // ipv4\n\n    case 41:\n      // ipv6\n      return bytes2ip(buf);\n\n    case 6: // tcp\n\n    case 273: // udp\n\n    case 33: // dccp\n\n    case 132:\n      // sctp\n      return bytes2port(buf).toString();\n\n    case 53: // dns\n\n    case 54: // dns4\n\n    case 55: // dns6\n\n    case 56: // dnsaddr\n\n    case 400: // unix\n\n    case 777:\n      // memory\n      return bytes2str(buf);\n\n    case 421:\n      // ipfs\n      return bytes2mh(buf);\n\n    case 444:\n      // onion\n      return bytes2onion(buf);\n\n    case 445:\n      // onion3\n      return bytes2onion(buf);\n\n    default:\n      return uint8ArrayToString(buf, 'base16');\n    // no clue. convert to hex\n  }\n}\nexport function convertToBytes(proto, str) {\n  const protocol = getProtocol(proto);\n\n  switch (protocol.code) {\n    case 4:\n      // ipv4\n      return ip2bytes(str);\n\n    case 41:\n      // ipv6\n      return ip2bytes(str);\n\n    case 6: // tcp\n\n    case 273: // udp\n\n    case 33: // dccp\n\n    case 132:\n      // sctp\n      return port2bytes(parseInt(str, 10));\n\n    case 53: // dns\n\n    case 54: // dns4\n\n    case 55: // dns6\n\n    case 56: // dnsaddr\n\n    case 400: // unix\n\n    case 777:\n      // memory\n      return str2bytes(str);\n\n    case 421:\n      // ipfs\n      return mh2bytes(str);\n\n    case 444:\n      // onion\n      return onion2bytes(str);\n\n    case 445:\n      // onion3\n      return onion32bytes(str);\n\n    default:\n      return uint8ArrayFromString(str, 'base16');\n    // no clue. convert from hex\n  }\n}\n\nfunction ip2bytes(ipString) {\n  if (!ip.isIP(ipString)) {\n    throw new Error('invalid ip address');\n  }\n\n  return ip.toBytes(ipString);\n}\n\nfunction bytes2ip(ipBuff) {\n  const ipString = ip.toString(ipBuff, 0, ipBuff.length);\n\n  if (ipString == null || !ip.isIP(ipString)) {\n    throw new Error('invalid ip address');\n  }\n\n  return ipString;\n}\n\nfunction port2bytes(port) {\n  const buf = new ArrayBuffer(2);\n  const view = new DataView(buf);\n  view.setUint16(0, port);\n  return new Uint8Array(buf);\n}\n\nfunction bytes2port(buf) {\n  const view = new DataView(buf.buffer);\n  return view.getUint16(buf.byteOffset);\n}\n\nfunction str2bytes(str) {\n  const buf = uint8ArrayFromString(str);\n  const size = Uint8Array.from(varint.encode(buf.length));\n  return uint8ArrayConcat([size, buf], size.length + buf.length);\n}\n\nfunction bytes2str(buf) {\n  const size = varint.decode(buf);\n  buf = buf.slice(varint.decode.bytes);\n\n  if (buf.length !== size) {\n    throw new Error('inconsistent lengths');\n  }\n\n  return uint8ArrayToString(buf);\n}\n\nfunction mh2bytes(hash) {\n  let mh;\n\n  if (hash[0] === 'Q' || hash[0] === '1') {\n    mh = Digest.decode(base58btc.decode(`z${hash}`)).bytes;\n  } else {\n    mh = CID.parse(hash).multihash.bytes;\n  } // the address is a varint prefixed multihash string representation\n\n\n  const size = Uint8Array.from(varint.encode(mh.length));\n  return uint8ArrayConcat([size, mh], size.length + mh.length);\n}\n/**\n * Converts bytes to bas58btc string\n */\n\n\nfunction bytes2mh(buf) {\n  const size = varint.decode(buf);\n  const address = buf.slice(varint.decode.bytes);\n\n  if (address.length !== size) {\n    throw new Error('inconsistent lengths');\n  }\n\n  return uint8ArrayToString(address, 'base58btc');\n}\n\nfunction onion2bytes(str) {\n  const addr = str.split(':');\n\n  if (addr.length !== 2) {\n    throw new Error(`failed to parse onion addr: [\"'${addr.join('\", \"')}'\"]' does not contain a port number`);\n  }\n\n  if (addr[0].length !== 16) {\n    throw new Error(`failed to parse onion addr: ${addr[0]} not a Tor onion address.`);\n  } // onion addresses do not include the multibase prefix, add it before decoding\n\n\n  const buf = base32.decode('b' + addr[0]); // onion port number\n\n  const port = parseInt(addr[1], 10);\n\n  if (port < 1 || port > 65536) {\n    throw new Error('Port number is not in range(1, 65536)');\n  }\n\n  const portBuf = port2bytes(port);\n  return uint8ArrayConcat([buf, portBuf], buf.length + portBuf.length);\n}\n\nfunction onion32bytes(str) {\n  const addr = str.split(':');\n\n  if (addr.length !== 2) {\n    throw new Error(`failed to parse onion addr: [\"'${addr.join('\", \"')}'\"]' does not contain a port number`);\n  }\n\n  if (addr[0].length !== 56) {\n    throw new Error(`failed to parse onion addr: ${addr[0]} not a Tor onion3 address.`);\n  } // onion addresses do not include the multibase prefix, add it before decoding\n\n\n  const buf = base32.decode(`b${addr[0]}`); // onion port number\n\n  const port = parseInt(addr[1], 10);\n\n  if (port < 1 || port > 65536) {\n    throw new Error('Port number is not in range(1, 65536)');\n  }\n\n  const portBuf = port2bytes(port);\n  return uint8ArrayConcat([buf, portBuf], buf.length + portBuf.length);\n}\n\nfunction bytes2onion(buf) {\n  const addrBytes = buf.slice(0, buf.length - 2);\n  const portBytes = buf.slice(buf.length - 2);\n  const addr = uint8ArrayToString(addrBytes, 'base32');\n  const port = bytes2port(portBytes);\n  return `${addr}:${port}`;\n}","map":{"version":3,"mappings":"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","names":["ip","getProtocol","CID","base32","base58btc","Digest","varint","toString","uint8ArrayToString","fromString","uint8ArrayFromString","concat","uint8ArrayConcat","convert","proto","a","Uint8Array","convertToString","convertToBytes","buf","protocol","code","bytes2ip","bytes2port","bytes2str","bytes2mh","bytes2onion","str","ip2bytes","port2bytes","parseInt","str2bytes","mh2bytes","onion2bytes","onion32bytes","ipString","isIP","Error","toBytes","ipBuff","length","port","ArrayBuffer","view","DataView","setUint16","buffer","getUint16","byteOffset","size","from","encode","decode","slice","bytes","hash","mh","parse","multihash","address","addr","split","join","portBuf","addrBytes","portBytes"],"sources":["E:\\PIAIC\\Quater04\\MyAPPs\\reactipfs\\node_modules\\@multiformats\\multiaddr\\src\\convert.ts"],"sourcesContent":["\nimport * as ip from './ip.js'\nimport { getProtocol } from './protocols-table.js'\nimport { CID } from 'multiformats/cid'\nimport { base32 } from 'multiformats/bases/base32'\nimport { base58btc } from 'multiformats/bases/base58'\nimport * as Digest from 'multiformats/hashes/digest'\nimport varint from 'varint'\nimport { toString as uint8ArrayToString } from 'uint8arrays/to-string'\nimport { fromString as uint8ArrayFromString } from 'uint8arrays/from-string'\nimport { concat as uint8ArrayConcat } from 'uint8arrays/concat'\n\n/**\n * converts (serializes) addresses\n */\nexport function convert (proto: string, a: string | Uint8Array) {\n  if (a instanceof Uint8Array) {\n    return convertToString(proto, a)\n  } else {\n    return convertToBytes(proto, a)\n  }\n}\n\n/**\n * Convert [code,Uint8Array] to string\n */\nexport function convertToString (proto: number | string, buf: Uint8Array) {\n  const protocol = getProtocol(proto)\n  switch (protocol.code) {\n    case 4: // ipv4\n    case 41: // ipv6\n      return bytes2ip(buf)\n\n    case 6: // tcp\n    case 273: // udp\n    case 33: // dccp\n    case 132: // sctp\n      return bytes2port(buf).toString()\n\n    case 53: // dns\n    case 54: // dns4\n    case 55: // dns6\n    case 56: // dnsaddr\n    case 400: // unix\n    case 777: // memory\n      return bytes2str(buf)\n\n    case 421: // ipfs\n      return bytes2mh(buf)\n    case 444: // onion\n      return bytes2onion(buf)\n    case 445: // onion3\n      return bytes2onion(buf)\n    default:\n      return uint8ArrayToString(buf, 'base16') // no clue. convert to hex\n  }\n}\n\nexport function convertToBytes (proto: string | number, str: string) {\n  const protocol = getProtocol(proto)\n  switch (protocol.code) {\n    case 4: // ipv4\n      return ip2bytes(str)\n    case 41: // ipv6\n      return ip2bytes(str)\n\n    case 6: // tcp\n    case 273: // udp\n    case 33: // dccp\n    case 132: // sctp\n      return port2bytes(parseInt(str, 10))\n\n    case 53: // dns\n    case 54: // dns4\n    case 55: // dns6\n    case 56: // dnsaddr\n    case 400: // unix\n    case 777: // memory\n      return str2bytes(str)\n\n    case 421: // ipfs\n      return mh2bytes(str)\n    case 444: // onion\n      return onion2bytes(str)\n    case 445: // onion3\n      return onion32bytes(str)\n    default:\n      return uint8ArrayFromString(str, 'base16') // no clue. convert from hex\n  }\n}\n\nfunction ip2bytes (ipString: string) {\n  if (!ip.isIP(ipString)) {\n    throw new Error('invalid ip address')\n  }\n  return ip.toBytes(ipString)\n}\n\nfunction bytes2ip (ipBuff: Uint8Array) {\n  const ipString = ip.toString(ipBuff, 0, ipBuff.length)\n  if (ipString == null || !ip.isIP(ipString)) {\n    throw new Error('invalid ip address')\n  }\n  return ipString\n}\n\nfunction port2bytes (port: number) {\n  const buf = new ArrayBuffer(2)\n  const view = new DataView(buf)\n  view.setUint16(0, port)\n\n  return new Uint8Array(buf)\n}\n\nfunction bytes2port (buf: Uint8Array) {\n  const view = new DataView(buf.buffer)\n  return view.getUint16(buf.byteOffset)\n}\n\nfunction str2bytes (str: string) {\n  const buf = uint8ArrayFromString(str)\n  const size = Uint8Array.from(varint.encode(buf.length))\n  return uint8ArrayConcat([size, buf], size.length + buf.length)\n}\n\nfunction bytes2str (buf: Uint8Array) {\n  const size = varint.decode(buf)\n  buf = buf.slice(varint.decode.bytes)\n\n  if (buf.length !== size) {\n    throw new Error('inconsistent lengths')\n  }\n\n  return uint8ArrayToString(buf)\n}\n\nfunction mh2bytes (hash: string) {\n  let mh\n\n  if (hash[0] === 'Q' || hash[0] === '1') {\n    mh = Digest.decode(base58btc.decode(`z${hash}`)).bytes\n  } else {\n    mh = CID.parse(hash).multihash.bytes\n  }\n\n  // the address is a varint prefixed multihash string representation\n  const size = Uint8Array.from(varint.encode(mh.length))\n  return uint8ArrayConcat([size, mh], size.length + mh.length)\n}\n\n/**\n * Converts bytes to bas58btc string\n */\nfunction bytes2mh (buf: Uint8Array) {\n  const size = varint.decode(buf)\n  const address = buf.slice(varint.decode.bytes)\n\n  if (address.length !== size) {\n    throw new Error('inconsistent lengths')\n  }\n\n  return uint8ArrayToString(address, 'base58btc')\n}\n\nfunction onion2bytes (str: string) {\n  const addr = str.split(':')\n  if (addr.length !== 2) {\n    throw new Error(`failed to parse onion addr: [\"'${addr.join('\", \"')}'\"]' does not contain a port number`)\n  }\n  if (addr[0].length !== 16) {\n    throw new Error(`failed to parse onion addr: ${addr[0]} not a Tor onion address.`)\n  }\n\n  // onion addresses do not include the multibase prefix, add it before decoding\n  const buf = base32.decode('b' + addr[0])\n\n  // onion port number\n  const port = parseInt(addr[1], 10)\n  if (port < 1 || port > 65536) {\n    throw new Error('Port number is not in range(1, 65536)')\n  }\n  const portBuf = port2bytes(port)\n  return uint8ArrayConcat([buf, portBuf], buf.length + portBuf.length)\n}\n\nfunction onion32bytes (str: string) {\n  const addr = str.split(':')\n  if (addr.length !== 2) {\n    throw new Error(`failed to parse onion addr: [\"'${addr.join('\", \"')}'\"]' does not contain a port number`)\n  }\n  if (addr[0].length !== 56) {\n    throw new Error(`failed to parse onion addr: ${addr[0]} not a Tor onion3 address.`)\n  }\n  // onion addresses do not include the multibase prefix, add it before decoding\n  const buf = base32.decode(`b${addr[0]}`)\n\n  // onion port number\n  const port = parseInt(addr[1], 10)\n  if (port < 1 || port > 65536) {\n    throw new Error('Port number is not in range(1, 65536)')\n  }\n  const portBuf = port2bytes(port)\n  return uint8ArrayConcat([buf, portBuf], buf.length + portBuf.length)\n}\n\nfunction bytes2onion (buf: Uint8Array) {\n  const addrBytes = buf.slice(0, buf.length - 2)\n  const portBytes = buf.slice(buf.length - 2)\n  const addr = uint8ArrayToString(addrBytes, 'base32')\n  const port = bytes2port(portBytes)\n  return `${addr}:${port}`\n}\n"]},"metadata":{},"sourceType":"module"}