{"ast":null,"code":"import { modeToString } from './mode-to-string.js';\nimport { parseMtime } from '../lib/parse-mtime.js';\n/**\n * @param {*} params\n * @returns {URLSearchParams}\n */\n\nexport function toUrlSearchParams() {\n  let {\n    arg,\n    searchParams,\n    hashAlg,\n    mtime,\n    mode,\n    ...options\n  } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n  if (searchParams) {\n    options = { ...options,\n      ...searchParams\n    };\n  }\n\n  if (hashAlg) {\n    options.hash = hashAlg;\n  }\n\n  if (mtime != null) {\n    mtime = parseMtime(mtime);\n    options.mtime = mtime.secs;\n    options.mtimeNsecs = mtime.nsecs;\n  }\n\n  if (mode != null) {\n    options.mode = modeToString(mode);\n  }\n\n  if (options.timeout && !isNaN(options.timeout)) {\n    // server API expects timeouts as strings\n    options.timeout = `${options.timeout}ms`;\n  }\n\n  if (arg === undefined || arg === null) {\n    arg = [];\n  } else if (!Array.isArray(arg)) {\n    arg = [arg];\n  }\n\n  const urlSearchParams = new URLSearchParams(options);\n  arg.forEach((\n  /** @type {any} */\n  arg) => urlSearchParams.append('arg', arg));\n  return urlSearchParams;\n}","map":{"version":3,"names":["modeToString","parseMtime","toUrlSearchParams","arg","searchParams","hashAlg","mtime","mode","options","hash","secs","mtimeNsecs","nsecs","timeout","isNaN","undefined","Array","isArray","urlSearchParams","URLSearchParams","forEach","append"],"sources":["E:/PIAIC/Quater04/MyAPPs/reactipfs/node_modules/ipfs-http-client/src/lib/to-url-search-params.js"],"sourcesContent":["import { modeToString } from './mode-to-string.js'\nimport { parseMtime } from '../lib/parse-mtime.js'\n\n/**\n * @param {*} params\n * @returns {URLSearchParams}\n */\nexport function toUrlSearchParams ({ arg, searchParams, hashAlg, mtime, mode, ...options } = {}) {\n  if (searchParams) {\n    options = {\n      ...options,\n      ...searchParams\n    }\n  }\n\n  if (hashAlg) {\n    options.hash = hashAlg\n  }\n\n  if (mtime != null) {\n    mtime = parseMtime(mtime)\n\n    options.mtime = mtime.secs\n    options.mtimeNsecs = mtime.nsecs\n  }\n\n  if (mode != null) {\n    options.mode = modeToString(mode)\n  }\n\n  if (options.timeout && !isNaN(options.timeout)) {\n    // server API expects timeouts as strings\n    options.timeout = `${options.timeout}ms`\n  }\n\n  if (arg === undefined || arg === null) {\n    arg = []\n  } else if (!Array.isArray(arg)) {\n    arg = [arg]\n  }\n\n  const urlSearchParams = new URLSearchParams(options)\n\n  arg.forEach((/** @type {any} */ arg) => urlSearchParams.append('arg', arg))\n\n  return urlSearchParams\n}\n"],"mappings":"AAAA,SAASA,YAAT,QAA6B,qBAA7B;AACA,SAASC,UAAT,QAA2B,uBAA3B;AAEA;AACA;AACA;AACA;;AACA,OAAO,SAASC,iBAAT,GAA0F;EAAA,IAA9D;IAAEC,GAAF;IAAOC,YAAP;IAAqBC,OAArB;IAA8BC,KAA9B;IAAqCC,IAArC;IAA2C,GAAGC;EAA9C,CAA8D,uEAAJ,EAAI;;EAC/F,IAAIJ,YAAJ,EAAkB;IAChBI,OAAO,GAAG,EACR,GAAGA,OADK;MAER,GAAGJ;IAFK,CAAV;EAID;;EAED,IAAIC,OAAJ,EAAa;IACXG,OAAO,CAACC,IAAR,GAAeJ,OAAf;EACD;;EAED,IAAIC,KAAK,IAAI,IAAb,EAAmB;IACjBA,KAAK,GAAGL,UAAU,CAACK,KAAD,CAAlB;IAEAE,OAAO,CAACF,KAAR,GAAgBA,KAAK,CAACI,IAAtB;IACAF,OAAO,CAACG,UAAR,GAAqBL,KAAK,CAACM,KAA3B;EACD;;EAED,IAAIL,IAAI,IAAI,IAAZ,EAAkB;IAChBC,OAAO,CAACD,IAAR,GAAeP,YAAY,CAACO,IAAD,CAA3B;EACD;;EAED,IAAIC,OAAO,CAACK,OAAR,IAAmB,CAACC,KAAK,CAACN,OAAO,CAACK,OAAT,CAA7B,EAAgD;IAC9C;IACAL,OAAO,CAACK,OAAR,GAAmB,GAAEL,OAAO,CAACK,OAAQ,IAArC;EACD;;EAED,IAAIV,GAAG,KAAKY,SAAR,IAAqBZ,GAAG,KAAK,IAAjC,EAAuC;IACrCA,GAAG,GAAG,EAAN;EACD,CAFD,MAEO,IAAI,CAACa,KAAK,CAACC,OAAN,CAAcd,GAAd,CAAL,EAAyB;IAC9BA,GAAG,GAAG,CAACA,GAAD,CAAN;EACD;;EAED,MAAMe,eAAe,GAAG,IAAIC,eAAJ,CAAoBX,OAApB,CAAxB;EAEAL,GAAG,CAACiB,OAAJ,CAAY;EAAC;EAAmBjB,GAApB,KAA4Be,eAAe,CAACG,MAAhB,CAAuB,KAAvB,EAA8BlB,GAA9B,CAAxC;EAEA,OAAOe,eAAP;AACD"},"metadata":{},"sourceType":"module"}